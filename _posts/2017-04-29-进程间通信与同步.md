---
layout:     post
title:      "进程间通信与同步"
date:       2017-4-10 
author:     "Wengdada"
header-img: 
catalog: true
tags:
    - OS
---


>操作系统为进程提供了必要的隔离，使得进程内部获得“封闭”的“可再现”执行环境。 但是也有很多场合需要进程间交互、协调完成任务，这就需要进程间通信手段以及同步手段。通信手段用于进程间的数据交换，而同步用于控制各自的执行步伐形成前后因果或互斥执行关系。

## 进程间通信

#### 进程间通信的概念
广义上 来说，两个进程通过**磁盘文件传递数据**也是进程间通信手段，同理利用**网络连接传递数据**也是 进程间通信。不过我们这里讨论更狭义的传统感念上的进程通信，也就是常说的**管道、消息队列、共享内存**等机制。

#### System V IPC
Linux 的进程通信继承了 System V IPC。System V IPC 指的是 AT&T 在 System V.2 发行版中 引入的三种进程间通信工具:
 (1)信号量，用来管理对共享资源的访问 
 (2)共享内存，用来高效地实现进程间的数据共享 
 (3)消息队列，用来实现进程间数据的传递。
我们把这三种工具统称为 System V IPC 的对象，每个对象都具有一个唯一的 IPC 标识符 ID。 为了使不同的进程能够获取同一个 IPC 对象，必须提供一个 IPC 关键字（IPC key），内核负责 把 IPC 关键字转换成 IPC 标识符 ID。下面我们观察这三种 IPC 工具。
在 Linux 中执行 ipcs 命令可以查看到当前系统中所有的 System V IPC 对象。

- IPC对象的相关命令

ipcs -a 是默认的输出全部信息、ipcs -m 显示共享内存的信息、ipcs -q 显示消息队列的信息、ipcs -s 显示信号量集的信息。另外用还有一些格式控 制的参数，–t 将会输出带时间信息、-p 将输出进程 PID 信息、-c 将输出创建者/拥有者的 PID、 -l 输出相关的限制条件。例如用 ipcs -ql 将显示消息队列的限制条件。

**删除这些 IPC 对象的命令是 ipcrm**，它会将与 IPC 对象及其相关联的数据也一起删除， 管 理员或者 IPC 对象的创建者才能执行删除操作。该命令可以使用 IPC 键或者 IPC 的 ID 来指定 IPC 对象：ipcrm -M shmkey 删除用 shmkey 创建的共享内存段而 ipcrm -m shmid 删除用 shmid 标识的共享内存段、ipcrm -Q msgkey 删除用 msqkey 创建的消息队列而 ipcrm -q msqid 删除用 msqid 标识的消息队列、ipcrm -S semkey 删除用 semkey 创建的信号而 ipcrm -s semid 删除用 semid 标识的信号。

#### 管道
进程间的管道通信有两种形式，**无名管道用于父子进程间，命名管可以用于任意进程间**— —命名管道在文件系统中有可访问的路径名。管道通信方式主要用于**单向通信**，如果需要**双向通信则建立两条相反方向的管道**。管道实质是由内核管理的一个缓冲区（一边由进程写入，另 一边由进程读出），因此要注意，如果缓冲区满了则写管道的进程将会阻塞。另外管道内部没 有显式的格式和边界，需要自行处理消息边界，如果多进程间共享还需要处理传送目标等工作。


###### 无名管道
- 简介

管道（pipe），或称无名管道，是所有 Unix 都提供的一种进程间通信机制。管道是单向的信道，进程从管道的写端口写入数据，需要数据的进程从读端口中获取数据，**数据在管道中按到达顺序流动**。Unix 命令中使用“|”来连接两个命令时使用的就是管道，例如“ls | more”将 ls命令的标准输出内容写入到管道中，管道的输出内容作为 more 命令的标准输入。注意，重 定向技术虽然看起来和管道很相似，例如“ls > temp”，但**重定向并不使用管道**。

- 以 ls|more 为例来认识管道

shell 程序在处理 ls|more 时，首先调用 pipe()系统调用，创建管道（其**核心就是一个内存缓冲区**）并返回一对**文件描述符**，比如文件描述符 3（用于管道的读端）和文件描述符 4（用于管道的写端）。然后**调用两次 fork()分别创建两个子进程**（后面会替换成 ls 和 more 两个进 程），此时两个子进程继承了 shell 的所打开的文件资源（含文件描述符 3 和 4），此时情形参见图 4-1。最后 shell 进程用 close()关闭文件并释放描述符 3 和 4（图 4-1 中用打叉的虚线表示关闭）。

![图 4-1 shell 调用 pipe()并创建两个子进程][1]

图 4-2 表明子进程 1 通过 dup2(4,1)，将文件描述符 4 拷贝到文件描述符 1（标准输出文件），然后用 close()关闭文件 3、4 并释放相应的描述符，最后执行execve()系统调用来执行 ls 程序，于是 ls的标准输出（对应文件描述符 1）内容都写入到管道的写端。
相似地，子进程 2 通过 dup2(3,0)将文件描述符 3 拷贝到文件描述符 0（标准输入文件）， 然后用 close()关闭文件 3、4 并释放相应的描述符，最后执行 execve()系统调用来执行 more 程 序，于是 more 从标准输入（对应文件描述符 0）读取的数据实际上就是管道的读端提供的数 据——即 ls 写入的数据。具体细节如图 4-2 所示，此时管道起到连接两个进程输入输出的作 用。
![图 4-2 ls 与 more 通过管道进行通信][2]




#### 消息对列
- 概念

消息队列中的消息可以通过类型（type）进行区分，因此可以用于多个进程间通信。
下面给出一个多功能的消息队列操作程序 msgtool.c（代码 4-2），读者从中学习如何使用 消息队列来进行进程间通信。由于 msgtool 每次启动都是以新的进程形式运行，为了能访问到指定的消息队列，我们需一个外部的“键”转换为内部的消息队列的ID，例如此处使用的是当前目录“.”并通过 frok()转换成内部ID。

```c
#include <stdio.h> 
#include <stdlib.h> 
#include <ctype.h>
#include <string.h> 
#include <sys/types.h> 
#include <sys/ipc.h> 
#include <sys/msg.h> 
#define MAX_SEND_SIZE 80

struct mymsgbuf { //消息的结构体 
 long mtype; //消息类型 
 char mtext[MAX_SEND_SIZE]; //消息内容
};

void send_message(int qid, struct mymsgbuf *qbuf, long type, char *text); 
void read_message(int qid, struct mymsgbuf *qbuf, long type);
void remove_queue(int qid);
void change_queue_mode(int qid, char *mode);
void usage(void);

 int main(int argc, char *argv[]){
 key_t key;
 int msgqueue_id; 
 struct mymsgbuf qbuf;

 if(argc == 1)
 	usage();

 /* Create unique key via call to ftok() */ 
 key = ftok(".", 'm');

 /* Open the queue - create if necessary */ 
 if((msgqueue_id = msgget(key, IPC_CREAT|0660)) == -1){ 
 	perror("msgget"); 
 	exit(1);
 }

 switch(tolower(argv[1][0])){
 case 's': send_message(msgqueue_id, (struct mymsgbuf*)&qbuf,atol(argv[2]), argv[3]);break;
 case 'r': read_message(msgqueue_id, &qbuf, atol(argv[2])); break;
 case 'd': remove_queue(msgqueue_id);break;
 case 'm': change_queue_mode(msgqueue_id, argv[2]); break;
 default: usage();
 }

 	return(0);
}

void send_message(int qid, struct mymsgbuf *qbuf, long type, char *text){
 /* Send a message to the queue */
 printf("Sending a message \n");
 qbuf->mtype = type; //填写消息的类型 
 strcpy(qbuf->mtext, text); //填写消息内容

 if((msgsnd(qid, (struct msgbuf *)qbuf, strlen(qbuf->mtext)+1, 0)) ==-1)
 {
 	perror("msgsnd"); 
 	exit(1);
 }
 	return;
}

void read_message(int qid, struct mymsgbuf *qbuf, long type){
 /* Read a message from the queue */
 printf("Reading a message \n");
 qbuf->mtype = type;
 msgrcv(qid, (struct msgbuf *)qbuf, MAX_SEND_SIZE, type, 0);

 printf("Type: %ld Text: %s\n", qbuf->mtype, qbuf->mtext); 
 return;
}

void remove_queue(int qid){
 /* Remove the queue */ 
 msgctl(qid, IPC_RMID, 0); 
 return;
}

void change_queue_mode(int qid, char *mode){
 struct msqid_ds myqueue_ds;

 /* Get current info */ 
 msgctl(qid, IPC_STAT, &myqueue_ds);

 /* Convert and load the mode */ 
 sscanf(mode, "%ho", &myqueue_ds.msg_perm.mode);

 /* Update the mode */ 
 msgctl(qid, IPC_SET, &myqueue_ds); 
 return;
}

void usage(void){
 fprintf(stderr, "msgtool - A utility for tinkering with msg queues\n"); 
 fprintf(stderr, "nUSAGE: msgtool (s)end \n");
 fprintf(stderr, " msgtool (r)ecv \n");
 fprintf(stderr, " msgtool (d)elete\n");
 fprintf(stderr, " msgtool (m)ode \n");
 exit(1);
}
```

msgtool.c 主函数中 首先打开（或创建）一个消息队列 msgget(key, IPC_CREAT|0660))，第一个参数就是前面通过 ftok() 将键转换而来的消息队列ID，第二个参数类似于文件打开的参数——IPC_CREAT 表示消息队列若是还不存在则创建一个新的、0660 表示创建者及其同组用户可以读（收）也可以写（发） 消息。然后根据命令行参数调用不同操作函数，如果是“s”则调用 send_message()发送一条消 息，“r”则调用 read_message()接受一条消息 ，如果是“d”则调用 remove_queue()删除指 定的消息队列， 最后如果是“m”则调用 change_queue_mode()改变消息队列的访问模式。

其中发送消息的核心函数是 msgsnd()，第一个参数是消息队列的 ID，第二个参数时被发送消息的起始地址（消息的第一个成员是一个整数用于指出消息类型），第三个参数时消息长度，第四个参数指定写消息时的一些行为（此例子用 0）；接受消息的函数是 msgrcv()，第一 个参数用于指定消息队列的ID，第二个参数是接受缓冲区地址，第三个参数指出希望接受的 消息类型（0表示接受任意类型的一条消息，>0 表示接受指定类型的消息，<0 则表示接受类 型数值小于该数字绝对值的一条消息）；删除和修改访问模式都是使用msgctl()（分别指出操作为IPC_RMID 或 IPC_SET）。



##### 共享内存
- 概念

System V IPC 的共享内存是**由内核提供的一段内存**，**可以映射到多个进程的续存空间上**，从而通过内存上的读写操作而完成进程间的数据共享。我们首先来看看如何创建共享内存的， 示例代码如下
所示
```c
代码 4-3 shmget-demo.c 代码
#include <sys/types.h> 
#include <sys/ipc.h> 
#include <sys/shm.h> 
#include <stdlib.h> 
#include <stdio.h>

#define BUFSZ 4096

int main ( void )
{
 int shm_id;

 shm_id=shmget(IPC_PRIVATE, BUFSZ, 0666 ) ; //创建共享内存 
 if (shm_id < 0 ) {
 perror( "shmget fail!\n" ) ;
 exit ( 1 );
 }

 printf ( "Successfully created segment : %d \n", shm_id ) ;
 system( "ipcs -m"); //执行 ipcs –m 命令，显示系统的共享内存信息 
 return 0;
}
```

它创建了一个 4096 字节的共享内存区。shmget()的第一个参数 IPC_PRIVATE（=0，表示创建新的共享内存），第二个参数是共享内存区的大小，第三个是访问 模式。虽然也可以像前面的消息队列的例子那样通过 ftok()将键值转换成 ID，但这里没有指定 ID，而是创建共享内存后由系统返回一个 ID 值（后面的进程要使用该共享内存时需要指定该 ID）。

下面展示另一个进程通过影射该共享内存而使用它的过程，具体如代码 4-4 所示。

代码 4-4 shmatt-write-demo.c 代码
```c
#include <sys/types.h> 
#include <sys/ipc.h> 
#include <sys/shm.h> 
#include <stdlib.h> 
#include <stdio.h> 
#include <string.h>

int main ( int argc, char *argv[] )
{
 int shm_id ; 
 char * shm_buf;

 if ( argc != 2 ){
 printf ( "USAGE: atshm <identifier>" ); 
 exit (1 );
 }

 shm_id = atoi(argv[1]);

 if ( (shm_buf = shmat( shm_id, 0, 0)) < (char *) 0 ){ //映射共享内存到进程空间 
 perror ( "shmat fail!\n" );
 exit (1);
 }

 printf ( " segment attached at %p\n", shm_buf );
 system("ipcs -m"); //显示共享内存信息 
 strcpy(shm_buf,"Hello shared memory!\n");
 getchar();

 if ( (shmdt(shm_buf)) < 0 ) { //解除共享内存的映射 
 perror ( "shmdt");
 exit(1);
 }

 printf ( "segment detached \n" ); 
 system ( "ipcs -m " );

 getchar(); 
 exit ( 0 );
}
```
完成共享内存的映射后，shmatt-write-demo 往共享内存中写入一个 字符串“Hello shared memory!”。shmatt-write-demo 还通过 system()执行了“ipcs -m”，因此 也输出了当前的共享内存信息，可以看到 ID 为 819203 的共享内存已经有被映射了一次 （nattach 列为 1）。
```
屏显 4-7 shmatt-write-demo 运行时的输出
[dada@localhost ~]$ shmatt-write-demo 884739 
 segment attached at 0x7f89e55fc000

------------ 共享内存段 --------------
键         shmid  拥有者  权限     字节     nattch   状态
0x00000000 131072 dada    600     524288   2       目标
0x00000000 163841 dada    600     4194304  2       目标
0x00000000 327682 dada    600     4194304  2       目标
0x00000000 884739 dada    666     4096     1
```
屏显第二行信息是该进程将共享内存映射到了进程空间 0x7f10ddf3a000 位置的地方，此时在另外一个终端上观察该进程的进程空间，可以看 到相应位置有一个新的区域 （7f89e55fc000-7f89e55fd000）。





![4-8 shmatt-write-demo映射共享内存时的进程布局][5]

击键回车后 shmat-write-demo 将解除共享内存的映射，此时 ipcs –m 显示对应的共享内 存区没有人使用（nattch 列为 0），如屏显 4-9 所示。此时如果检查进程布局，将发现 7f89e55fc000-7f89e55fd000 区间的虚存已经没有了。
![4-9 shmatt-demo运行时的输出][4]

此时再尝试用另一个程序去映射该共享内存并从中读取数据，如代码 4-5 所示。

```c
代码 4-5 shmatt-read-demo.c 代码
 int main ( int argc, char *argv[] ){
 int shm_id ; 
 char * shm_buf;

 if ( argc != 2 ){
 	printf ( "USAGE: atshm <identifier>" ); 
	exit (1 );
 }

 shm_id = atoi(argv[1]);

 if ( (shm_buf = shmat( shm_id, 0, 0)) < (char *) 0 ){ 
 	perror ( "shmat fail!\n" ); 
 	exit (1);
 }

 printf ( " segment attached at %p\n", shm_buf );
 system("ipcs -m");
 printf("The string in SHM is :%s\n",shm_buf); //将共享内存区的内容打印出来 
 getchar();

 if ( (shmdt(shm_buf)) < 0 ){ 
 	perror ( "shmdt"); 
 	exit(1);
 }

 printf ( "segment detached \n" ); 
 system ( "ipcs -m " );

 getchar(); 
 exit ( 0 );
}
```
虽然创建该共享内存的进程已经结束了，可是 shmatt-read-demo 映射 ID 为的共享内存后， 仍读出了原来写入的字符串，如所示。
![4-10 shmatt-read-demo的部分输出][3]

从上面实验看出**共享内存是比较灵活的通信方式**，不需要像管道那要用文件接口 read()、 write()等函数，也不需要像消息队列那样用 msgsend()/msgrcv()等函数来操作，直接用内存指针 方式就可以操作。虽然实验中没有验证其容量，但是**共享内存的容量远比管道和消息队列大。**


  [1]: https://raw.githubusercontent.com/GitHub-Weng/GitHub-Weng.github.io/master/img/communication%20and%20synchoronization%20between%20processes/using_pipe_create_2_process.jpg
  [2]: https://raw.githubusercontent.com/GitHub-Weng/GitHub-Weng.github.io/master/img/communication%20and%20synchoronization%20between%20processes/ls_more_pipe.jpg
  [3]: https://raw.githubusercontent.com/GitHub-Weng/GitHub-Weng.github.io/master/img/communication%20and%20synchoronization%20between%20processes/shmatt_read_demo_part_output.jpg
  [4]: https://raw.githubusercontent.com/GitHub-Weng/GitHub-Weng.github.io/master/img/communication%20and%20synchoronization%20between%20processes/shmatt_demo.jpg
  [5]: https://raw.githubusercontent.com/GitHub-Weng/GitHub-Weng.github.io/master/img/communication%20and%20synchoronization%20between%20processes/map_share_memory.jpg